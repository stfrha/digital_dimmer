###############################################################################
##
## Copyright (c) 1995-2002 Xilinx, Inc.  All rights reserved.
##
## Xilinx, Inc.
##
## xmdterm.tcl
##
## XMD Terminal User Interface
##
## $Header: /devl/xcs/repo/env/Jobs/MDT/sw/debug/xmd/DataFiles/flashwriter.tcl,v 1.17 2004/12/23 23:48:26 vasanth Exp $
##
###############################################################################
puts "Flashwriter starting..."

;# Set a default for the flash boot config here, that can be overridden in the flash_params.tcl.
set FLASH_BOOT_CONFIG "DEFAULT"
set COMPILER_FLAGS  -g

;# -------------------- -------------------- -------------------- 
;# Get required parameters from flash_params.tcl.
;# flash_params.tcl will be auto-generated by XPS
;# -------------------- -------------------- -------------------- 
source etc/flash_params.tcl

;# -------------------- -------------------- -------------------- -------------------- 
;# Global variables
;# -------------------- -------------------- -------------------- -------------------- 

set TMP_DATA_FILE               "data.tmp"              ;# Hash defines for this script
set debug_script 0                                      ;# Turn this to 1 to enable debug messages

;# Mailbox defines
set cmdoffset                   0 
set statusoffset                1
set paramsoffset                4

set BASE_ADDR_PARAM             0
set BUS_WIDTH_PARAM             1
set ADDR_SHIFT_PARAM            2

set ADDR_PARAM                  0
set NBYTES_PARAM                1

set PROG_OFFSET_PARAM           0
set DATA_BYTES_COUNT_PARAM      1
set SRCADDR_PARAM               2

set DEV_ALGO_PARAM              0
set NUM_PARTS_PARAM             1
set PART_MODE_PARAM             2
set PART_SIZ_PARAM              3

set ERR_CODE_PARAM              0

;# CMD defines
set CMD_NONE               49       ;# '0'
set CMD_CFI_QRY            67       ;# 'C' 
set CMD_INIT_DEV           73       ;# 'I'
set CMD_ERASE_DEV          69       ;# 'E'
set CMD_BLK_ERASE_DEV      66       ;# 'B'
set CMD_RST_DEV            82       ;# 'R'
set CMD_PROG_DEV           80       ;# 'P'
set CMD_BATCH              98       ;# 'b'
set CMD_EXIT               88       ;# 'X'

;# Send and receive mailbox addresses
set sndmbox             0
set rcvmbox             0

set membufptr           0
set membufsiz           0

set timeout             0

;# XMD Target ID of the processor that we use
set target              0

;# Info about the flashwriter
set FLASHWRITER_ELF     0
set FLASHWRITER_SIZE    0

;# Device Algorithm
set DEV_ALGO            -1

;# -------------------- -------------------- -------------------- -------------------- -------------------- -------------------- 


;#
;# flashwriter - Main flashwriter driver routine
;#
proc flashwriter { } {
    
    global FLASH_BASEADDR 
    global FLASH_BUSWIDTH 
    global FLASH_PROG_OFFSET
    global XMD_CONNECT   
    global TARGET_TYPE
    global FLASHWRITER_ELF
    global FLASHWRITER_SIZE
    global FLASH_FILE
    global target

    global cmdoffset
    global statusoffset
    global paramsoffset
    global PROG_OFFSET_PARAM
    global DATA_BYTES_COUNT_PARAM
    global BASE_ADDR_PARAM
    global BUS_WIDTH_PARAM
    global ADDR_SHIFT_PARAM
    global SRCADDR_PARAM
    global ADDR_PARAM
    global NBYTES_PARAM

    global sndmbox
    global rcvmbox
    global membufsiz
    global membufptr
    global timeout

    ;# CMD defines
    global CMD_NONE  
    global CMD_INIT_DEV
    global CMD_CFI_QRY
    global CMD_ERASE_DEV
    global CMD_BLK_ERASE_DEV 
    global CMD_RST_DEV   
    global CMD_PROG_DEV  
    global CMD_BATCH
    global CMD_EXIT      
    
    global TMP_DATA_FILE
    global SCRATCH_BASEADDR
    
    global FLASH_PROG_MODE
    global DEV_ALGO
    global env


    ;# -------------------- -------------------- -------------------- 
    ;# Connect to target processor on the board
    ;# -------------------- -------------------- -------------------- 

    fconfigure stdout -buffering none
    iprint "Connecting to target..."

    eval $XMD_CONNECT

    set tglist [xtargets]
    if { [llength $tglist] == 0 } {
	iprintln "ERROR: XMD reports no targets connected"
        flashwriter_error_out
    }
    set target [lindex $tglist 0]
    iprintln "done."

    ;# -------------------- -------------------- --------------------
    ;# Open channel to the image file to be programmed to flash
    ;# -------------------- -------------------- -------------------- 
    iprint "Opening image file to be programmed..."  
    if { [catch { open $FLASH_FILE "r"} fid] } {                        
        iprintln "ERROR: Unable to open flash image file: $FLASH_FILE"
        flashwriter_error_out
    }
    
    fconfigure $fid -translation binary
    seek $fid 0 end                                                     ;# work out file length in bytes
    set flash_file_len [tell $fid]
    seek $fid 0 start
    set nbytes $flash_file_len                  
    iprintln "done."

    ;# -------------------- -------------------- --------------------
    ;# Setup flashwriter application sources into user project area. 
    ;# - Obtain sources from install area
    ;# -------------------- -------------------- --------------------
    setup_writer_sources
    set FLASHWRITER_ELF [file join "." "etc" "flashwriter" "flashwriter.elf"]

    ;# -------------------- -------------------- --------------------
    ;# Compile and execute flashwriter for CFI Query
    ;# -------------------- -------------------- --------------------
    compile_writer "CFI Query Mode" "FW_MODE_CFIQRY"
    download_writer_and_prepare 0
    iprint "Performing CFI Query on the flash part(s)..."   
    mwr [expr $sndmbox + $cmdoffset] $CMD_CFI_QRY 1 b
    mwr [expr $sndmbox + [param2offset $BASE_ADDR_PARAM]] $FLASH_BASEADDR
    mwr [expr $sndmbox + [param2offset $BUS_WIDTH_PARAM]] $FLASH_BUSWIDTH 
    eval_xmd_cmd "xcontinue $target"
    wait_for_writer
    if { [check_writer_status] == 1 } {
        cleanup_writer
        flashwriter_error_out
    }
    iprintln "done."
    set devinfo [extract_flash_info]
    print_flash_info                            ;# This is critical. Dev algo is retrieved and set here

    set fw_support [algo_to_str $DEV_ALGO "FW_SUPPORT"]


    ;# -------------------- -------------------- --------------------
    ;# Compile and execute flashwriter for block erase
    ;# -------------------- -------------------- --------------------
    compile_writer "Block Erase Mode" "FW_MODE_ERASE" $fw_support
    download_writer_and_prepare $devinfo
    iprint "Erasing appropriate flash block(s)..."   

    ;# CMD_INIT_DEV
    mwr [expr $sndmbox + $cmdoffset] $CMD_INIT_DEV 1 b
    eval_xmd_cmd "xcontinue $target"
    wait_for_writer
    if { [check_writer_status] == 1 } {
        cleanup_writer
        flashwriter_error_out
    }

    ;# CMD_BLK_ERASE_DEV
    mwr [expr $sndmbox + $cmdoffset] $CMD_BLK_ERASE_DEV 1 b
    mwr [expr $sndmbox + [param2offset $ADDR_PARAM]] $FLASH_PROG_OFFSET
    mwr [expr $sndmbox + [param2offset $NBYTES_PARAM]] $nbytes
    eval_xmd_cmd "xcontinue $target"
    wait_for_writer
    if { [check_writer_status] == 1 } {
        cleanup_writer
        flashwriter_error_out
    }

    iprintln "done."
    ;# -------------------- -------------------- --------------------
    ;# Erase the part completely 
    ;# -------------------- -------------------- --------------------
    #    iprint "Erasing flash part..."                                       ;# Erase the part(s) completely

    #    download_writer_and_prepare $devinfo
    #    iprint "Erasing appropriate flash block(s)..."   

    #    ;# CMD_INIT_DEV
    #    mwr [expr $sndmbox + $cmdoffset] $CMD_INIT_DEV 1 b
    #    eval_xmd_cmd "xcontinue $target"
    #    wait_for_writer
    #    if { [check_writer_status] == 1 } {
    #        cleanup_writer
    #        flashwriter_error_out
    #    }

    #    mwr [expr $sndmbox + $cmdoffset] $CMD_ERASE_DEV 1 b
    #    eval_xmd_cmd "xcontinue $target"
    #    wait_for_writer
    #    if { [check_writer_status] == 1 } {
    #         cleanup_writer  
    #         flashwriter_error_out
    #    }
    #    iprintln "done."
    
    
    ;# -------------------- -------------------- --------------------
    ;# Program the part with the image
    ;# -------------------- -------------------- --------------------

    compile_writer "Program Mode" "FW_MODE_PROG" $fw_support
    download_writer_and_prepare $devinfo
    
    iprintln "Programming of the flash part with the image started."
    set progoffset $FLASH_PROG_OFFSET

    ;# CMD_INIT_DEV
    mwr [expr $sndmbox + $cmdoffset] $CMD_INIT_DEV 1 b
    eval_xmd_cmd "xcontinue $target"
    wait_for_writer
    if { [check_writer_status] == 1 } {
        cleanup_writer
        flashwriter_error_out
    }
   
    ;# Streaming program of target part 
    ;# We use this when the user does not want to program the flash part at one-shot. We therefore break the data file into parts,
    ;# and download it into a memory buffer in the flashwriter's area. The size of the buffer was queried previously
    if { $FLASH_PROG_MODE == "STREAMING" } {
        set bytesdone 0
        while { $nbytes != 0 } {
            if { $nbytes > $membufsiz } {
                set datablk [read $fid $membufsiz]
                set count  $membufsiz
            } else {
                set datablk [read $fid $nbytes]
                set count $nbytes
            }
            
            ;# Since we want to take advantage of fast download
            ;# we use XMD's dow command to store blocks of data into memory
            ;# Therefore create temporary files to hold the data and use in dow
            if { [catch {open $TMP_DATA_FILE "w"} datafid] } {                              
                iprintln "ERROR: Unable to create temporary data file: $TMP_DATA_FILE"                
                cleanup_writer
                flashwriter_error_out                                                                      
            }
            
            fconfigure $datafid -translation binary
            puts -nonewline $datafid $datablk
            close $datafid

            if { [catch {eval_xmd_cmd "xdownload $target -data $TMP_DATA_FILE $membufptr"}] } {
                iprintln "ERROR: Unable to download a block of data to Flashwriter data buffer ($membufptr)"                
                cleanup_writer
                flashwriter_error_out
            }            

            ;# CMD_PROG_DEV
            dprint "Sending CMD_PROG_DEV to writer..."    
            mwr [expr $sndmbox + $cmdoffset] $CMD_PROG_DEV 1 b
            mwr [expr $sndmbox + [param2offset $PROG_OFFSET_PARAM]] $progoffset 
            mwr [expr $sndmbox + [param2offset $DATA_BYTES_COUNT_PARAM]] $count
            eval_xmd_cmd "xcontinue $target"
            wait_for_writer
            if { [check_writer_status] == 1 } {
                cleanup_writer
                flashwriter_error_out
            }        
            
            set nbytes [expr $nbytes - $count]
            set progoffset [expr $progoffset + $count]
            set bytesdone [expr $bytesdone + $count]

            iprint "Progress: "
            ;# iprint [format "%6.2f%%\b\b\b\b\b\b\b" [expr $bytesdone * 100.0 / $flash_file_len]]
            iprintln [format "%6.2f%%" [expr $bytesdone * 100.0 / $flash_file_len]]
	    flush stdout
        }
        
        iprintln ""
    } else {
        
        ;# Oneshot program of target part 
        ;# User has some enough temporary, non-conflicting memory to download the entire image.
        ;# We therefore download the image to that location and point the writer to that location and ask it 
        ;# to finish the programming in one-shot
        set FLASHWRITER_SIZE [calculate_fw_size]
        set tmp_scratch_area [expr [expr $SCRATCH_BASEADDR + $FLASHWRITER_SIZE] + 0x100]
        set tmp_scratch_area [expr $tmp_scratch_area + [expr 4 - [expr $tmp_scratch_area % 4]]]

        ;# CMD_BATCH
        dprint "Sending CMD_BATCH to writer..."
        mwr [expr $sndmbox + $cmdoffset] $CMD_BATCH 1 b
        mwr [expr $sndmbox + [param2offset $PROG_OFFSET_PARAM]] $FLASH_PROG_OFFSET 
        mwr [expr $sndmbox + [param2offset $DATA_BYTES_COUNT_PARAM]] $nbytes
        mwr [expr $sndmbox + [param2offset $SRCADDR_PARAM]] $tmp_scratch_area
        iprint "Downloading image file completely to memory..."
        if { [catch {eval_xmd_cmd "xdownload $target -data $FLASH_FILE $tmp_scratch_area"}] } {
            iprintln "ERROR: Unable to download $FLASH_FILE to scratch area ($tmp_scratch_area)"                
            cleanup_writer
            flashwriter_error_out
        }
        iprintln "done."
        iprint "Programming image completely in one-shot..."
        eval_xmd_cmd "xcontinue $target"
        wait_for_writer
        if { [check_writer_status] == 1 } {
            cleanup_writer
            flashwriter_error_out
        }        
        iprintln "done."
    }
    
    iprintln "Programming completed successfully."

    ;# -------------------- -------------------- --------------------
    ;# Cleanup the flashwriter, indicate success and terminate
    ;# -------------------- -------------------- --------------------

    cleanup_writer
    cleanup_files

    close $fid

    iprintln "Flashwriter terminating..."
}

;#
;# download_writer_and_prepare - Download flashwriter and initialize data structures required to talk to the flashwriter.
;#
proc download_writer_and_prepare { devinfo } {
    global sndmbox
    global rcvmbox
    global membufptr
    global membufsiz   
    global target
    global FLASHWRITER_ELF

    ;# -------------------- -------------------- --------------------
    ;# Download and peek into the flashwriter to get the mailbox 
    ;# info. Set a breakpoint in the flashwriter callback routine 
    ;# This way we can rendezvous with the flashwriter.
    ;# -------------------- -------------------- --------------------
    eval_xmd_cmd "xreset $target"

    iprint "Downloading flashwriter to memory..." 
    eval_xmd_cmd "xdownload $target $FLASHWRITER_ELF"
    iprintln "done."

    ;# These are the memory locations where the flashwriter looks for commands and parameters
    ;# We use XMD's mrd_var command to figure out the values of these locations and re-use them later on in this script
    set sndmbox   [read_var "rcvptr"]
    set rcvmbox   [read_var "sndptr"]
    set membufptr [read_var "membufptr"]
    set membufsiz [read_var "membufsiz"]

    ;# If requested, populate the devinfo structure in the memory
    if { $devinfo != 0 } {      
        set devinfop   [read_var "devinfop"]
        set i 0

        foreach byte $devinfo {
            mwr [expr $devinfop + $i] $byte 1 b
            incr i
        }
    }

    bps_function "xmd_callback"
}

;#
;# extract_flash_info - Get the devinfo structure from memory
;#
proc extract_flash_info { } {
    global target

    set devinfop   [read_var "devinfop"]
    set devinfosz  [read_var "devinfosz"]

    for {set i 0} {$i < $devinfosz} {incr i} {
        lappend devinfo [eval_xmd_cmd "xrmem $target [expr $devinfop + $i] 1"]
    }

    return $devinfo
}

;#
;# print_flash_info - Dump info about the flash parts found
;#
proc print_flash_info { } {
    global target
    global rcvmbox
    global FLASH_BOOT_CONFIG
    global DEV_ALGO_PARAM
    global NUM_PARTS_PARAM
    global PART_MODE_PARAM
    global PART_SIZ_PARAM
    global DEV_ALGO

    set dev_algo_l   [eval_xmd_cmd "xrmem $target [expr $rcvmbox + [param2offset $DEV_ALGO_PARAM]] 4"]
    set num_parts_l  [eval_xmd_cmd "xrmem $target [expr $rcvmbox + [param2offset $NUM_PARTS_PARAM]] 4"]
    set part_mode_l [eval_xmd_cmd "xrmem $target [expr $rcvmbox + [param2offset $PART_MODE_PARAM]] 4"]
    set part_siz_l   [eval_xmd_cmd "xrmem $target [expr $rcvmbox + [param2offset $PART_SIZ_PARAM]] 4"]

    set word 0
    for {set i 0} {$i < 4} {incr i} {
        set word [expr ($word << 8) + [lindex $dev_algo_l $i]]
    }
    set dev_algo $word

    set word 0
    for {set i 0} {$i < 4} {incr i} {
        set word [expr ($word << 8) + [lindex $num_parts_l $i]]
    }
    set num_parts $word

    set word 0
    for {set i 0} {$i < 4} {incr i} {
        set word [expr ($word << 8) + [lindex $part_mode_l $i]]
    }
    set part_mode $word

    set word 0
    for {set i 0} {$i < 4} {incr i} {
        set word [expr ($word << 8) + [lindex $part_siz_l $i]]
    }
    set part_siz $word

    puts "Flash part information: "
    puts "Device Algorithm      \t: [algo_to_str $dev_algo VENDOR]"
    puts "Number of flash parts\t: $num_parts"
    puts "Width of each flash part: $part_mode bits wide"
    puts "Size of each flash part\t: [expr [expr $part_siz / 1024] / 1024] MB"
    puts "Flash boot config     \t: $FLASH_BOOT_CONFIG"

    ;# Mark the algo found in the global algo flag
    set DEV_ALGO $dev_algo
}

;#
;# setup_writer_sources
;# 
proc setup_writer_sources {} {
    global PROC_INSTANCE

    iprintln "Setting up Flashwriter sources for compilation --"  
    set xilinx_edk [lindex [array get env XILINX_EDK] 1]
    set procdir [file join "." $PROC_INSTANCE]
    set proc_lib_dir [file join $procdir "lib"]

    set flashwriter_src [file join "." "sw_services" "flashwriter" "src"]
    ;# set flashwriter_src [file join $xilinx_edk "data" "xmd" "flashwriter" "src"]

    file delete -force "./etc/flashwriter"
    file mkdir "./etc/flashwriter"
    iprint "Copying flashwriter sources from $flashwriter_src to ./etc/flashwriter/src..."
    file copy -force $flashwriter_src "./etc/flashwriter/"
    iprintln "done."
    
}

;#
;# compile_writer
;#
proc compile_writer { mode args } {
    global TARGET_TYPE
    global PROC_INSTANCE
    global FLASH_BOOT_CONFIG
    global SCRATCH_BASEADDR
    global COMPILER_FLAGS

    iprint "Compiling flashwriter ($mode)..."
    
    set procdir [file join "." $PROC_INSTANCE]
    set proc_lib_dir [file join $procdir "lib"]
    set config_file_name [file join "." "etc" "flashwriter" "src" "config.h"]
    set config_file [reopen_writer_config_file $config_file_name]

    if { $FLASH_BOOT_CONFIG != "DEFAULT" } {
        puts $config_file "\#define $FLASH_BOOT_CONFIG"
    }

    foreach ele $args {
        puts $config_file "\#define $ele"
    }

    close $config_file 

    if { ![string compare -nocase $TARGET_TYPE "microblaze"] } {
        set compile_status [catch {exec mb-gcc -Os $COMPILER_FLAGS ./etc/flashwriter/src/flashwriter.c ./etc/flashwriter/src/cfi.c ./etc/flashwriter/src/flash.c ./etc/flashwriter/src/amd.c ./etc/flashwriter/src/intel.c  -I ./etc/flashwriter/src/ -Wl,-defsym -Wl,_TEXT_START_ADDR=$SCRATCH_BASEADDR -L $proc_lib_dir -o ./etc/flashwriter/flashwriter.elf} err]
    } else {
        set compile_status [catch {exec powerpc-eabi-gcc -Os $COMPILER_FLAGS ./etc/flashwriter/src/flashwriter.c ./etc/flashwriter/src/cfi.c ./etc/flashwriter/src/flash.c ./etc/flashwriter/src/amd.c ./etc/flashwriter/src/intel.c -I ./etc/flashwriter/src/ -Wl,-defsym -Wl,_START_ADDR=$SCRATCH_BASEADDR -Wl,-T -Wl,./etc/flashwriter/src/flashwriter.ld -L $proc_lib_dir -o ./etc/flashwriter/flashwriter.elf} err]
    }        

    if { $compile_status } {
        iprintln ""
        puts "ERROR: Unable to compile flashwriter application. Please check if XILINX_EDK has been set correctly and all the EDK GNU tools are available"
        flashwriter_error_out
    } else {
        iprintln "done."
    }

    ;# file copy -force [file join "." "etc" "flashwriter" "flashwriter.elf"] [file join "." "$mode.elf"]
    ;# file copy -force [file join "." "etc" "flashwriter" "src" "config.h"] [file join "." "$mode.h"]
}

;#
;# reopen_writer_config_file - Delete and re-open the flashwriter configuration header.
;#
proc reopen_writer_config_file { filename } {
    if { [catch { open $filename "w+"} fid] } {                        
        iprintln "ERROR: Unable to open flashwriter configuration file: $filename"
        flashwriter_error_out
    }

    return $fid
}


;#
;# algo_to_str - Get the symbolic string describing the algorithm, given an algorithm number
;#               or, flashwriter support string, given an algorithm number
;#
proc algo_to_str { dev_algo type}  {

    set vend_id_list        [list 0 1 2 3 4 256 257]
    set vend_str_list       [list "No vendor" "Intel/Sharp Extended" "AMD/Fujitsu Standard" "Intel Standard" "AMD/Fujitsu Extended" "Mitsubishi Standard" "Mitsubishi Extended"]
    set fw_support_str_list [list "FW_SUPPORT_ERROR" "FW_SUPPORT_INTEL" "FW_SUPPORT_AMD" "FW_SUPPORT_INTEL" "FW_SUPPORT_AMD" "FW_SUPPORT_ERROR" "FW_SUPPORT_ERROR"]
    set index [lsearch $vend_id_list $dev_algo]

    if {$index == -1} {
        puts "ERROR: Unknown flash algorithm requested by flash part!"
        flashwriter_error_out
    } elseif {$index == 256 || $index == 257} {
        puts "ERROR: Unsupported flash algorithm (Mitsubishi Standard/Extended) required by your flash part !"
        flashwriter_error_out
    }

    if { $type == "VENDOR" } {
        set retstr [lindex $vend_str_list $index]
    } else {  ;# type == "FW_SUPPORT"
        set retstr [lindex $fw_support_str_list $index]
    }
    return $retstr
}


;#
;# check_writer_status - Check if writer has indicated error. If so clean up the writer and return
;#
proc check_writer_status { } {
    global statusoffset 
    global rcvmbox
    global target
    global ERR_CODE_PARAM

    set STATUS_IDLE            73         ;# 'I'
    set STATUS_BUSY            66         ;# 'B'
    set STATUS_ERR             69         ;# 'E'
    set STATUS_SUCCESS         83         ;# 'S'
    set STATUS_EXIT            88         ;# 'X'
    
    set status [eval_xmd_cmd "xrmem $target [expr $rcvmbox + $statusoffset] 1"]
    if { $status != $STATUS_SUCCESS && $status != $STATUS_IDLE } {
        set errcode [eval_xmd_cmd "xrmem $target [expr $rcvmbox + [param2offset $ERR_CODE_PARAM]] 4"]
        set word 0
        for {set i 0} {$i < 4} {incr i} {
            set word [expr ($word << 8) + [lindex $errcode $i]]
        }        
        set errstr [report_flashwriter_error $word]
        iprintln "ERROR: Flashwriter application reported an error: $errstr"
        return 1
    }
    
    return 0
}


;#
;# cleanup_writer - Check if writer has indicated error. If so clean up the writer and return
;#
proc report_flashwriter_error {errcode} {
    set err_str_list [list "No error" "Target does not support requested operation !"  "Unable to query target part layout !" "Not a CFI compliant flash device - Did not scan a P-R-I !" "CFI QRY of block info returned inconsistent results" "CFI QRY ran out of space to accomodate region information" "Flash timeout error !" "The flash sequence provided was incorrect !" "The flash erase operation errored out !" "The flash block erase operation errored out !" "The flash programming operation errored out !" "The flash operation ran into a lock error !" "The flash part ran into a voltage error !"]

    return [lindex $err_str_list $errcode]
}

;#
;# cleanup_writer - Check if writer has indicated error. If so clean up the writer and return
;#
proc cleanup_writer { } {
    global sndmbox
    global cmdoffset
    global CMD_EXIT
    global FLASHWRITER_ELF
    global TMP_DATA_FILE
    global target
    
    dprint "Sending CMD_EXIT to writer..."
    mwr [expr $sndmbox + $cmdoffset] $CMD_EXIT 1 b
    bpr_function "xmd_callback"
    eval_xmd_cmd "xcontinue $target"
}

;#
;# calculate_fw_size - Calculate the size of the flashwriter ELF application using the GNU tools
;#
proc calculate_fw_size {} {
    global FLASHWRITER_ELF
    global TARGET_TYPE

    iprint "Calculating flashwriter application size..."
    if { ![string compare -nocase $TARGET_TYPE "microblaze"] } {
        if { [catch {set total [exec mb-size -A $FLASHWRITER_ELF | grep Total]} err] } {
            puts "ERROR: Unable to determine the size of the flashwriter application. Please check if XILINX_EDK has been set correctly and all the EDK tools are available"
            flashwriter_error_out
        }

    } else {
        if { [catch {set total [exec powerpc-eabi-size -A $FLASHWRITER_ELF | grep Total]} err] } {
            puts "ERROR: Unable to determine the size of the flashwriter application. Please check if XILINX_EDK has been set correctly and all the EDK tools are available"
            flashwriter_error_out
        }
    }
    iprintln "done."

    set total_list [split $total]    
    foreach ele $total_list {
        if { [string is integer -strict $ele] } {
            set size $ele
            break
        }
    }
    return $size
}

;#
;# flashwriter_error_out - Terminate the writer gracefully and return error
;# 
proc flashwriter_error_out { } {
    cleanup_files
    iprintln "Flashwriter terminating !"
    exit 1
}

;#
;# cleanup_files - Cleanup all the writer files
;#
proc cleanup_files {} {
    global TMP_DATA_FILE

    file delete -force $TMP_DATA_FILE
    file delete -force "./etc/flashwriter"
}

proc wait_for_writer { } {
    global target
    
    dprint "Waiting for writer..."
    set status  1 
    set timeout 0
    while { $status != 0 } {
        after 1000 "settimeout"
        vwait timeout
        set status [eval_xmd_cmd "xstate $target"]
    }
}
    

;#
;# param2offset - Utility; Given a parameter number, calculate its offset (4 * param number)
;#
proc param2offset { param } {
    global paramsoffset 
    set ret [expr [expr $param * 4] + $paramsoffset]
    return $ret
}


proc settimeout { } {
    global timeout
    set timeout 1
}

;#
;# dprint - Debug print routine
;#
proc dprint { msg } {
    global debug_script

    if { $debug_script == 1 } {
            puts $msg
    }
}

;#
;# iprintln - Information print routine with newline.
;#
proc iprintln { msg } {
    puts $msg
}

;#
;# iprint - Information print routine. 
;#
proc iprint { msg } {
    puts -nonewline $msg
}

;#
;# read_var - Utility routine to read a variable from the application's memory space
;#
proc read_var { varname } {
    global FLASHWRITER_ELF
    global target

    return [mrd_var $varname $FLASHWRITER_ELF]
}

;#
;# bps_function - Utility routine to set a breakpoint at a function in the flashwriter memory
;#
proc bps_function { funcname } {
    global FLASHWRITER_ELF
    bps $funcname 
}

;#
;# bps_function - Utility routine to remove a breakpoint at a function in the flashwriter memory
;#
proc bpr_function { funcname } {
    global FLASHWRITER_ELF
    bpr $funcname 
}

# proc read_var { varname {size 4} } {
#     global FLASHWRITER_BASE
#     global FLASHWRITER_ELF
#     global target

#     set addr [find_symbol_read $FLASHWRITER_ELF $varname]
#     set addr [expr $FLASHWRITER_BASE + $addr]

#     set val_list [xrmem $target $addr $size]   

#     set word 0
#     for {set i 0} {$i < $size} {incr i} {
#         set word [expr ($word << 8) + [lindex $val_list $i]]
#     }
    
#     return $word
# }

# proc read_ptr { varname {size 4} } {
#     global FLASHWRITER_BASE
#     global FLASHWRITER_ELF
#     global target

#     set addr [find_symbol_read $FLASHWRITER_ELF $varname]
#     set addr [expr $FLASHWRITER_BASE + $addr]

#     set val_list [xrmem $target $addr $size]   

#     set word 0
#     for {set i 0} {$i < $size} {incr i} {
#         set word [expr ($word << 8) + [lindex $val_list $i]]
#     }
    
#     return [expr $FLASHWRITER_BASE + $word]
# }

# proc bps_function { funcname } {
#     global FLASHWRITER_BASE
#     global FLASHWRITER_ELF
#     global target

#     set addr [find_symbol_read $FLASHWRITER_ELF $funcname]
#     set addr [expr $FLASHWRITER_BASE + $addr]

#     xbreakpoint $target $addr sw
# }

# proc bpr_function { funcname } {
#     global FLASHWRITER_BASE
#     global FLASHWRITER_ELF
#     global target

#     set addr [find_symbol_read $FLASHWRITER_ELF $funcname]
#     set addr [expr $FLASHWRITER_BASE + $addr]

#     xremove $target $addr
# }

flashwriter
exit 0
